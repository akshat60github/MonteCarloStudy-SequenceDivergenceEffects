Synthetic Dataset generation

1. 
import random

# first im defining the bases and specifying all parameters.
dna_bases = 'ATGC'
sequence_length = 155
motif_length = 8
# generating the motif first
motif = "".join(random.choices(dna_bases, k=motif_length)) #using random
# now generating the full length random sequence
full_sequence = "".join(random.choices(dna_bases, k=sequence_length))
# im choosing a random start position for the motif to be placed, ensures the motif will fit entirely within the sequence
start_index = random.randint(0, sequence_length - motif_length)
# lastly i will overwrite the part of the sequence with the actual motif
# we build the new sequence from three pieces:
# a) the part before the motif
# b) the motif itself
# c) the part after the motif
original_sequence = full_sequence[:start_index] + motif + full_sequence[start_index + motif_length:]

print(f"original motif: {motif}")
print(f"sequence (of length {len(original_sequence)}):")
print(original_sequence)


2. 
import random
# function that creates a single mutated copy
def mutate_sequence(sequence, divergence_level, include_indels=True):
    #introduces mutations into a sequence. can include indels or only substitutions.
    mutated_list = list(sequence)
    i = 0
    while i < len(mutated_list):
        if random.random() < divergence_level:
            if not include_indels:
                mutation_type = 'substitution'
            else:
                mutation_type = random.choices(
                    ['substitution', 'insertion', 'deletion'],
                    weights=[80, 10, 10]
                )[0]
            if mutation_type == 'substitution':
                current_base = mutated_list[i]
                possible_new_bases = [b for b in dna_bases if b != current_base]
                if possible_new_bases:
                    mutated_list[i] = random.choice(possible_new_bases)
            elif mutation_type == 'insertion':
                new_base = random.choice(dna_bases)
                mutated_list.insert(i + 1, new_base)
                i += 1
            elif mutation_type == 'deletion':
                mutated_list.pop(i)
                continue
        i += 1
    return "".join(mutated_list)

#demonstration of the function at each divergence level
divergence_levels_to_test = [0.01, 0.05, 0.10, 0.20]
print("testing the mutation function at different levels.")
for level in divergence_levels_to_test:
    # example for each level to show it works
    test_mutation = mutate_sequence(original_sequence, level)
    print(f"example mutation at {level*100:.0f}% divergence:\n{test_mutation}\n")


3. 
#parameters
divergence_levels = [0.01, 0.05, 0.10, 0.20]
num_replicates = 40
# initializing a dictionary to store all the data
synthetic_data = {}
print("generating the full replicate dataset.")

# loop over each divergence level
for level in divergence_levels:
    replicates_for_level = []
    # create the specified number of replicates for this level
    for _ in range(num_replicates):
        # call the function defined in step 2
        mutated_seq = mutate_sequence(original_sequence, level, include_indels=True)
        replicates_for_level.append(mutated_seq)
    # store the list of replicates in the main dictionary
    synthetic_data[level] = replicates_for_level
    print(f"generated {len(replicates_for_level)} replicates for {level*100:.0f}% divergence.")

print("\n data generation complete.")
# now "synthetic_data" holds all the mutated sequences, organized by divergence level.



--------------------------------------------------------------------------------------------------------------------------------
